		1. Make sure math structs has proper = operator overload
		
		
		
		
		GLfloat vertices[] =
		{
			4.0f,  4.5f / 2.0f, 0,		// Bottom right
			4.0f, -4.5f / 2.0f, 0,		// Top right
			-4.0f, -4.5f / 2.0f, 0,		// Top left
			-4.0f,  4.5f / 2.0f, 0		// Bottom left
		};

		GLushort indices[]
		{
			0, 1, 2, 0, 2, 3
		};

		VertexArray vao;
		Buffer* vbo = new Buffer(vertices, 4 * 3, 3);
		IndexBuffer ibo(indices, 6);

		vao.addBuffer(vbo, 0);

		mat4 ortho = mat4::orthographic(-8.0f, 8.0f, 4.5f, -4.5f, -1.0f, 1.0f);

		Shader shader("graphics/shaders/basic.vert", "graphics/shaders/basic.frag");
		shader.enable();
		shader.setUniformMat4("pr_matrix", ortho);
		//shader.setUniformMat4("ml_matrix", mat4::translation(vec3(-4.0f, -4.5/2.0f, 0.0f)));
		shader.setUniform4f("in_Color", vec4(1.0f, 0.0f, 1.0f, 1.0f));

		vec2 lightPos(-8.0f, 0.0f);
		vec2 lightSpeed(0.2f, 0.2f);
		while (!renderer.windowClosed()) {
			//renderer.render();
			renderer.clear();
			//glDrawArrays(GL_TRIANGLES, 0, 6);
			vao.bind();
			ibo.bind();

			if (lightPos.x > 8.0f || lightPos.x < -8.0f) {
				lightSpeed.x *= -1.0f;
			}

			if (lightPos.y > 4.5f/2.0f || lightPos.y < -4.5f / 2.0f) {
				lightSpeed.y *= -1.0f;
			}

			lightPos.x += lightSpeed.x;
			lightPos.y += lightSpeed.y;


			shader.setUniform2f("light_position", lightPos);
			shader.setUniformMat4("ml_matrix", mat4::translation(vec3(-4.0f, 0.0f, 0.0f)));
			glDrawElements(GL_TRIANGLES, ibo.getCount(), GL_UNSIGNED_SHORT, 0);
			shader.setUniformMat4("ml_matrix", mat4::translation(vec3(4.0f, 0.0f, 0.0f)));
			glDrawElements(GL_TRIANGLES, ibo.getCount(), GL_UNSIGNED_SHORT, 0);
			ibo.unbind();
			vao.unbind();
			renderer.update();
		}

			/*program->enable();

	glGenVertexArrays(1, &VAO);
	glGenBuffers(1, &VBO);
	glBindVertexArray(VAO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, RENDERER_BUFFER_SIZE, NULL, GL_DYNAMIC_DRAW);

	glEnableVertexAttribArray(SHADER_VERTEX_INDEX);
	glVertexAttribPointer(SHADER_VERTEX_INDEX, 3, GL_FLOAT, GL_FALSE, RENDERER_VERTEX_SIZE, (const GLvoid*)0);

	glEnableVertexAttribArray(SHADER_COLOR_INDEX);
	glVertexAttribPointer(SHADER_COLOR_INDEX, 4, GL_UNSIGNED_BYTE, GL_FALSE, RENDERER_VERTEX_SIZE, (const GLvoid*)(offsetof(GSSComponent::VertexData, GSSComponent::VertexData::color)));
	
	glEnableVertexAttribArray(SHADER_UV_INDEX);
	glVertexAttribPointer(SHADER_UV_INDEX, 2, GL_FLOAT, GL_TRUE, RENDERER_VERTEX_SIZE, (const GLvoid*)(offsetof(GSSComponent::VertexData, GSSComponent::VertexData::uv)));

	glBindBuffer(GL_ARRAY_BUFFER, 0);	

	GLuint* indices = new GLuint[RENDERER_INDICES_SIZE];

	int offset = 0;
	for (int i = 0; i < RENDERER_INDICES_SIZE; i += 6) {
		indices[  i  ] = offset + GSSComponent::indices[0];
		indices[i + 1] = offset + GSSComponent::indices[1];
		indices[i + 2] = offset + GSSComponent::indices[2];

		indices[i + 3] = offset + GSSComponent::indices[3];
		indices[i + 4] = offset + GSSComponent::indices[4];
		indices[i + 5] = offset + GSSComponent::indices[5];

		offset += 4;
	}

	IBO = new IndexBuffer(indices, RENDERER_INDICES_SIZE);

	glBindVertexArray(0);


	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	GSSComponent::VertexData* buffer = (GSSComponent::VertexData*)glMapBuffer(GL_ARRAY_BUFFER, GL_WRITE_ONLY);

	for (int i = 0; i < components->size(); i++)
	{
		components->at(i)->updateUV();
		const vec3& position = components->at(i)->position;
		const vec2& scale = components->at(i)->scale;
		const vec4& color = components->at(i)->color;
		const vec2* uv = components->at(i)->uv;

		int r = color.x * 255.0f;
		int g = color.y * 255.0f;
		int b = color.z * 255.0f;
		int a = color.w * 255.0f;

		unsigned int c = a << 24 | b << 16 | g << 8 | r;

		buffer->vertex = GSSComponent::vertices[0] + vec2(scale.x, 0);
		buffer->color = c;
		buffer->uv = uv[0];
		buffer++;

		buffer->vertex = GSSComponent::vertices[1] + vec2(scale.x, scale.y);
		buffer->color = c;
		buffer->uv = uv[1];
		buffer++;

		buffer->vertex = GSSComponent::vertices[2] + vec2(0, scale.y);
		buffer->color = c;
		buffer->uv = uv[2];
		buffer++;

		buffer->vertex = GSSComponent::vertices[3];
		buffer->color = c;
		buffer->uv = uv[3];
		buffer++;

		indexCount += 6;
	}

	std::cout << "Indices:" << std::endl;
	for (int i = 0; i < indexCount; i += 6) {
		std::cout << indices[i + 0] << ", " << indices[i + 1] << ", " << indices[i + 2] << ", " << indices[i + 3] << ", " << indices[i + 4] << ", " << indices[i + 5] << std::endl;
	}

	glActiveTexture(GL_TEXTURE0);
	glBindTexture(GL_TEXTURE_2D, TextureAtlas::getAtlas(TextureAtlas::Atlas::TEST)->getTextureID());
	GLuint texLoc = glGetUniformLocation(program->getProgramID(), "tex");
	glUniform1i(texLoc, 0);

	/*GLuint texture = TextureAtlas::getAtlas(TextureAtlas::Atlas::TEST)->getTextureID();
	glActiveTexture(texture);
	glBindTexture(GL_TEXTURE_2D, texture);
	program->setUniform1i("tex", glGetUniformLocation(program->getProgramID(), "tex")); // Takes in textureunit
	//glActiveTexture(0);

	 

	glUnmapBuffer(GL_ARRAY_BUFFER);
	glBindBuffer(GL_ARRAY_BUFFER, 0);

	glBindVertexArray(VAO);
	IBO->bind();

	glDrawElements(GL_TRIANGLES, indexCount, GL_UNSIGNED_INT, NULL);

	IBO->unbind();
	glBindVertexArray(0);

	

	program->disable();*/


	#version 330 core

layout (location = 0) out vec4 out_Color;

uniform vec2 light_position;

in DATA
{
	vec4 position;
	vec4 color;
	vec2 uv;
} fs_in;

uniform sampler2D tex1;

void main()
{
	float intensity = 1.0 / length(fs_in.position.xy - light_position);
	out_Color = vec4(1.0, 1.0, 1.0, 1.0);/*fs_in.color * intensity;*/
	/*out_Color = texture(tex1, fs_in.uv) * intensity;*/
}


#version 330 core

layout (location = 0) in vec4 position;
layout (location = 1) in vec4 color; 
layout (location = 2) in vec2 uv;

uniform mat4 pr_matrix;
uniform mat4 vw_matrix = mat4(1.0);
uniform mat4 ml_matrix = mat4(1.0);

out DATA
{
	vec4 position;
	vec4 color;
	vec2 uv;
} vs_out;

void main()
{

	gl_Position = pr_matrix * vw_matrix * ml_matrix * position;
	vs_out.position = ml_matrix * position;
	vs_out.uv = uv;
	vs_out.color = color;
}